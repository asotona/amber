/*
 * Copyright (c) 2021, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the "Classpath" exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package java.lang;

import java.lang.invoke.*;
import java.lang.invoke.MethodHandles.Lookup;
import java.util.concurrent.ConcurrentHashMap;

/**
 * Provides runtime support for templated strings. Primarily to handle the bootstrapping
 * of templated string call sites.
 */
final class TemplateSupport {

    /**
     * MethodHandle to TemplatePolicy.apply.
     */
    static final MethodHandle APPLY_MH;

    /**
     * Initialize MethodHandle constant
     */
    static {
        try {
            Lookup lookup = MethodHandles.lookup();
            APPLY_MH = lookup.findVirtual(TemplatePolicy.class, "apply",
                    MethodType.methodType(Object.class, TemplatedString.class));
        } catch (ReflectiveOperationException ex) {
            throw new RuntimeException(ex);
        }
    }

    /**
     * Constructor.
     */
    private TemplateSupport() {
    }

    /**
     * This internal (package private) class is used to delegate template policy to an appropriate
     * apply method.  Determination of the delegate is based on the receiver's class, a
     * {@link TemplatePolicy} implementation.
     */
    static final class Bootstrap {

        /**
         * Maximum number of cached policies per callsite.
         */
        private static final int CALLSITE_LIMIT = 8;

        /**
         * Constructor.
         */
        private Bootstrap() {
        }

        /**
         * Base BSM used to construct a call site for templated string. This method is delegated
         * by {@link TemplatedString} to handle the invokeDynamic generated by templated
         * string byte code.
         *
         * @param type  bootstrap method type
         *
         * @return call site for templated string
         */
        static CallSite templatedStringBSM(MethodType type) {
            TemplateCallSite callsite = new TemplateCallSite(type);
            callsite.setTarget(callsite.bootstrap());

            return callsite;
        }

        /**
         * Call site used to track {@link TemplatePolicy} implementations.
         * The call site caches multiple targets for polymorphic situations where
         * a number of different policies act as receivers.
         */
        private static class TemplateCallSite extends MutableCallSite {
            /**
             * MethodHandle to the callsite managing method.
             */
            private static final MethodHandle CALLSITE_MH;

            /**
             * Initialize MethodHandle constant
             */
            static {
                try {
                    Lookup lookup = MethodHandles.lookup();
                    CALLSITE_MH = lookup.findVirtual(TemplateCallSite.class, "callsite",
                            MethodType.methodType(Object.class, Class.class, MethodHandle.class,
                                    TemplatePolicy.class, TemplatedString.class));
                } catch (ReflectiveOperationException ex) {
                    throw new RuntimeException(ex);
                }
            }

            /**
             * Cache of template policy targets. The cache is keyed on template policy class.
             */
            final ConcurrentHashMap<Class<?>, MethodHandle> policyCache;

            /**
             * Constructor.
             *
             * @param type  bootstrap method type
             */
            TemplateCallSite(MethodType type) {
                super(type);
                this.policyCache = new ConcurrentHashMap<>();
            }

            /**
             * Locates a {@link TemplatePolicy} {@link MethodHandle}. This method first searches
             * the callsite cache, and failing that, asks the template policy to construct specialized
             * {@link MethodHandle}.
             *
             * @param policy           receiving {@link TemplatePolicy}
             * @param templatedString  templated string object
             *
             * @return a specialized {@link TemplatePolicy} {@link MethodHandle}
             */
            MethodHandle findPolicy(TemplatePolicy<?, ?> policy, TemplatedString templatedString) {
                // Prevent the cache from growing significantly.
                if (policyCache.size() > CALLSITE_LIMIT) {
                    policyCache.clear();
                }

                return policyCache.computeIfAbsent(policy.getClass(),
                        policyType -> {
                            return policy.applyMethodHandle(templatedString);
                        });
            }

            /**
             * Manage the templated string call site.
             *
             * @param oldclass         class last seen (may be bound)
             * @param mh               MethodHandle last used (may be bound)
             * @param receiver         receiving template policy
             * @param templatedString  templated string object
             *
             * @return result from template policy
             *
             * @throws Throwable exception thrown by template policy
             */
            Object callsite(Class<?> oldclass, MethodHandle mh,
                            TemplatePolicy<?, ?> policy, TemplatedString templatedString) throws Throwable {
                try {
                    Class<?> newClass = policy.getClass();

                    if (!newClass.equals(oldclass)) {
                        mh = findPolicy(policy, templatedString);
                        mh = MethodHandles.insertArguments(CALLSITE_MH, 0, this, newClass, mh);
                        setTarget(mh.asType(type()));
                    }

                    return (Object)mh.invokeExact(policy, templatedString);
                } catch (NullPointerException ex) {
                    throw new RuntimeException("null template policy", ex);
                }
            }

            /**
             * Returns a bootstrapping MethodHandle. Triggers a template policy lookup on first call.
             *
             * @return bootstrapping MethodHandle
             */
            MethodHandle bootstrap() {
                MethodHandle mh = MethodHandles.insertArguments(CALLSITE_MH, 0, this, null, null)
                        .asType(type());

                return mh;
            }
        }

    }

}
